<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Slope Analyzer — Omar Yaseen</title>

<!-- CSS -->
<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet.draw/1.0.4/leaflet.draw.css"/>
<style>
  :root{--accent:#0b7285;--bg:#f6fbfd}
  body{margin:0;font-family:Inter,Arial,Helvetica;background:var(--bg);color:#111}
  header{background:linear-gradient(90deg,#0b7285,#66c2ff);color:white;padding:12px 14px}
  header h1{margin:0;font-size:17px}
  .wrap{display:grid;grid-template-columns:1fr 400px;gap:12px;padding:12px}
  @media(max-width:920px){.wrap{grid-template-columns:1fr;}}
  #map{height:560px;border-radius:8px;box-shadow:0 6px 18px rgba(0,0,0,0.08)}
  .panel{background:#fff;padding:12px;border-radius:10px;box-shadow:0 6px 18px rgba(12,20,24,0.06)}
  label{display:block;font-weight:600;margin-top:8px}
  input,textarea,select,button{width:100%;padding:8px;margin-top:6px;border-radius:8px;border:1px solid #d8e2e8}
  textarea{min-height:84px;font-family:monospace}
  .coords{font-family:monospace;font-size:13px;color:#445;white-space:pre-wrap;max-height:160px;overflow:auto}
  table{width:100%;border-collapse:collapse;font-size:13px}
  th,td{padding:6px;border:1px solid #eef}
  .small{font-size:13px;color:#556}
  .row{display:flex;gap:8px}
  .row > *{flex:1}
  .muted{color:#6b7}
  #xsChart{width:100%;height:220px}
  footer{text-align:center;padding:10px;color:#333}
  a.link{color:var(--accent);text-decoration:none}
  .error{color:#d9534f;background:#fdf2f2;padding:8px;border-radius:4px;margin:8px 0}
  .success{color:#2e7d32;background:#f2fdf2;padding:8px;border-radius:4px;margin:8px 0}
  
  /* New styles for visualizations */
  .viz-container {margin-top:12px; display:none;}
  .viz-tabs {display:flex; gap:8px; margin-bottom:12px;}
  .viz-tab {padding:8px 16px; background:#f0f0f0; border-radius:6px; cursor:pointer; border:none; font-size:13px;}
  .viz-tab.active {background:var(--accent); color:white;}
  .viz-content {display:none;}
  .viz-content.active {display:block;}
  #demCanvas, #flowCanvas, #threeDView {width:100%; height:300px; background:#f8f9fa; border-radius:8px; border:1px solid #ddd;}
  #threeDContainer {width:100%; height:300px; background:#1a1a1a; border-radius:8px; position:relative; overflow:hidden;}
  .viz-controls {margin-top:8px; display:flex; gap:8px; flex-wrap:wrap;}
  .viz-controls button {flex:1; min-width:120px;}
  .legend {display:flex; align-items:center; gap:10px; margin-top:8px; font-size:12px;}
  .legend-color {width:20px; height:20px; border:1px solid #ccc;}
  .viz-info {margin-top:8px; font-size:12px; color:#666;}
</style>
</head>
<body>
<header>
  <h1>Slope Analyzer — draw / upload / paste • Cross-section & slopes</h1>
  <div class="small">Map: OpenStreetMap • Elevation: OpenTopoData (SRTM) or Open-Elevation. Calculations shown with sources.</div>
</header>

<div class="wrap">
  <!-- left: map + chart -->
  <div>
    <div id="map" class="panel"></div>

    <div class="panel" style="margin-top:12px">
      <h3>Cross-section</h3>
      <canvas id="xsChart"></canvas>
    </div>

    <!-- NEW: Visualizations Panel -->
    <div class="panel viz-container" style="margin-top:12px" id="vizPanel">
      <h3>3D Visualization & Analysis</h3>
      <div class="viz-tabs">
        <button class="viz-tab active" data-viz="dem">DEM View</button>
        <button class="viz-tab" data-viz="threed">3D View</button>
        <button class="viz-tab" data-viz="flow">Flow Direction</button>
      </div>
      
      <div class="viz-content active" id="demViz">
        <canvas id="demCanvas"></canvas>
        <div class="legend">
          <div class="legend-color" style="background:#000080"></div><span>Low Elevation</span>
          <div class="legend-color" style="background:#008000"></div><span>Medium</span>
          <div class="legend-color" style="background:#FFFF00"></div><span>High</span>
          <div class="legend-color" style="background:#FF0000"></div><span>Peak</span>
        </div>
        <div class="viz-controls">
          <button id="btnExportDEM">Export DEM Image</button>
          <button id="btnToggleHillshade">Toggle Hillshade</button>
        </div>
      </div>
      
      <div class="viz-content" id="threedViz">
        <div id="threeDContainer">
          <canvas id="threeDView"></canvas>
        </div>
        <div class="viz-info">Click and drag to rotate • Scroll to zoom</div>
        <div class="viz-controls">
          <button id="btnReset3D">Reset View</button>
          <button id="btnExport3D">Export 3D Image</button>
        </div>
      </div>
      
      <div class="viz-content" id="flowViz">
        <canvas id="flowCanvas"></canvas>
        <div class="legend">
          <div style="color:#d9534f">▼</div><span>Downhill Direction</span>
          <div style="color:#0066cc">●</div><span>Steep Slope</span>
          <div style="color:#66cc66">●</div><span>Gentle Slope</span>
        </div>
        <div class="viz-controls">
          <button id="btnExportFlow">Export Flow Map</button>
        </div>
      </div>
    </div>

    <div class="panel" style="margin-top:12px">
      <h3>Export</h3>
      <div class="small">Download a CSV of the computed points/segments</div>
      <button id="btnExportCSV">Export CSV</button>
      <div class="small" style="margin-top:8px">Open locally? Use Firefox or run a tiny server:
        <code>python -m http.server 8000</code>
      </div>
    </div>
  </div>

  <!-- right: controls & results -->
  <aside>
    <div class="panel">
      <h3>Inputs & Controls</h3>

      <label>Mode</label>
      <select id="mode">
        <option value="draw">Draw polygon / line (use draw tools)</option>
        <option value="manual">Manual coordinates (lat,lng per line)</option>
        <option value="kml">Upload KML (Polygon or LineString)</option>
      </select>

      <div id="drawBlock" style="margin-top:8px">
        <div class="small">Use the drawing control on the map to draw polygon or line. Click map to add points when not drawing.</div>
      </div>

      <div id="manualBlock" style="display:none">
        <label>Manual coordinates (lat,lng per line)</label>
        <textarea id="manualCoords" placeholder="31.95,35.91"></textarea>
        <button id="btnLoadManual">Load Coordinates</button>
      </div>

      <div id="kmlBlock" style="display:none">
        <label>Upload KML</label>
        <input type="file" id="kmlfile" accept=".kml"/>
      </div>

      <label>Go to coordinates (lat,lng)</label>
      <div class="row">
        <input id="goto" placeholder="31.95,35.91"/>
        <button id="btnGo">Go</button>
      </div>

      <label>Sampling distance along line (m)</label>
      <input id="sampleDist" type="number" value="50"/>

      <label>Elevation source (batch)</label>
      <select id="elevSource">
        <option value="opentopodata">OpenTopoData (SRTM) — recommended</option>
        <option value="opentopodata-aster">OpenTopoData (ASTER) — alternative</option>
        <option value="open-elevation">Open-Elevation (public)</option>
        <option value="airbus-elevation">Airbus Elevation API (Free)</option>
        <option value="nationalmap-usgs">USGS National Map (US only)</option>
      </select>

      <div id="statusMessage"></div>

      <div class="row" style="margin-top:8px">
        <button id="btnClear">Clear</button>
        <button id="btnAnalyze">Analyze</button>
      </div>

      <label style="margin-top:10px">Map coordinates / actions</label>
      <div class="small">Tap the map to add a point (or draw). Click a sample marker to see elev & source.</div>
      <div class="coords" id="coordsBox">No geometry yet</div>
    </div>

    <div class="panel" style="margin-top:12px">
      <h3>Summary Results</h3>
      <div id="summary">No results yet</div>
    </div>

    <div class="panel" style="margin-top:12px">
      <h3>Detailed table</h3>
      <div id="tableBox">No data</div>
    </div>

    <div class="panel" style="margin-top:12px">
      <h4>Sources & credits</h4>
      <div class="small">
        Map tiles: OpenStreetMap contributors. Elevation: chosen source (OpenTopoData or Open-Elevation). Calculations performed client-side (haversine distances, shoelace area).<br/>
        Made by <a class="link" href="https://www.linkedin.com/in/omaryaseen" target="_blank">Omar Yaseen</a>.
      </div>
    </div>
  </aside>
</div>

<footer>
  <div class="small">Tip: If opening from a local file causes issues on Android, open in Firefox or serve via a tiny web server.</div>
</footer>

<!-- libs -->
<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet.draw/1.0.4/leaflet.draw.js"></script>
<script src="https://cdn.jsdelivr.net/npm/togeojson@0.16.0/dist/togeojson.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

<script>
// ---------- NEW: Proper Visualization System ----------
class TerrainVisualizer {
  constructor() {
    this.demCanvas = document.getElementById('demCanvas');
    this.demCtx = this.demCanvas.getContext('2d');
    this.flowCanvas = document.getElementById('flowCanvas');
    this.flowCtx = this.flowCanvas.getContext('2d');
    this.threeDCanvas = document.getElementById('threeDView');
    this.threeDCtx = this.threeDCanvas.getContext('2d');
    
    this.showHillshade = true;
    this.isDragging = false;
    this.lastMouseX = 0;
    this.lastMouseY = 0;
    this.rotationX = -30;
    this.rotationY = 45;
    this.zoom = 1.0;
    
    this.setupEventListeners();
    this.setCanvasSizes();
  }

  setCanvasSizes() {
    const canvases = [this.demCanvas, this.flowCanvas, this.threeDCanvas];
    canvases.forEach(canvas => {
      canvas.width = canvas.offsetWidth;
      canvas.height = canvas.offsetHeight;
    });
  }

  setupEventListeners() {
    // 3D view mouse controls
    this.threeDCanvas.addEventListener('mousedown', (e) => this.handleMouseDown(e));
    this.threeDCanvas.addEventListener('mousemove', (e) => this.handleMouseMove(e));
    this.threeDCanvas.addEventListener('mouseup', () => this.handleMouseUp());
    this.threeDCanvas.addEventListener('wheel', (e) => this.handleWheel(e));
    
    // Control buttons
    document.getElementById('btnToggleHillshade').addEventListener('click', () => {
      this.showHillshade = !this.showHillshade;
      this.updateDEM();
    });
    
    document.getElementById('btnReset3D').addEventListener('click', () => {
      this.rotationX = -30;
      this.rotationY = 45;
      this.zoom = 1.0;
      this.update3D();
    });
    
    // Export buttons
    document.getElementById('btnExportDEM').addEventListener('click', () => this.exportCanvas(this.demCanvas, 'dem'));
    document.getElementById('btnExport3D').addEventListener('click', () => this.exportCanvas(this.threeDCanvas, '3d'));
    document.getElementById('btnExportFlow').addEventListener('click', () => this.exportCanvas(this.flowCanvas, 'flow'));
  }

  handleMouseDown(e) {
    this.isDragging = true;
    this.lastMouseX = e.clientX;
    this.lastMouseY = e.clientY;
  }

  handleMouseMove(e) {
    if (!this.isDragging) return;
    
    const deltaX = e.clientX - this.lastMouseX;
    const deltaY = e.clientY - this.lastMouseY;
    
    this.rotationY += deltaX * 0.5;
    this.rotationX += deltaY * 0.5;
    
    this.lastMouseX = e.clientX;
    this.lastMouseY = e.clientY;
    
    this.update3D();
  }

  handleMouseUp() {
    this.isDragging = false;
  }

  handleWheel(e) {
    e.preventDefault();
    this.zoom += e.deltaY * -0.001;
    this.zoom = Math.max(0.1, Math.min(3.0, this.zoom));
    this.update3D();
  }

  exportCanvas(canvas, type) {
    const link = document.createElement('a');
    link.download = `${type}_visualization.png`;
    link.href = canvas.toDataURL();
    link.click();
  }

  updateAll(samplePoints) {
    if (!samplePoints || samplePoints.length === 0) return;
    
    this.samplePoints = samplePoints;
    this.setCanvasSizes();
    this.updateDEM();
    this.update3D();
    this.updateFlow();
  }

  updateDEM() {
    const { width, height } = this.demCanvas;
    const ctx = this.demCtx;
    
    // Clear
    ctx.fillStyle = '#1a1a1a';
    ctx.fillRect(0, 0, width, height);
    
    if (!this.samplePoints) return;
    
    const elevs = this.samplePoints.map(p => p.elev);
    const minElev = Math.min(...elevs);
    const maxElev = Math.max(...elevs);
    const elevRange = Math.max(1, maxElev - minElev);
    
    // Create proper DEM grid
    const gridSize = Math.max(5, Math.min(20, width / this.samplePoints.length));
    const cols = Math.floor(width / gridSize);
    const rows = Math.floor(height / gridSize);
    
    // Draw elevation grid
    for (let x = 0; x < cols; x++) {
      for (let y = 0; y < rows; y++) {
        const sampleIndex = Math.floor((x / cols) * this.samplePoints.length);
        const elev = this.samplePoints[sampleIndex].elev;
        const normalized = (elev - minElev) / elevRange;
        
        // Color based on elevation
        let color;
        if (normalized < 0.25) {
          color = this.interpolateColor([0, 0, 128], [0, 128, 0], normalized / 0.25);
        } else if (normalized < 0.5) {
          color = this.interpolateColor([0, 128, 0], [255, 255, 0], (normalized - 0.25) / 0.25);
        } else if (normalized < 0.75) {
          color = this.interpolateColor([255, 255, 0], [255, 165, 0], (normalized - 0.5) / 0.25);
        } else {
          color = this.interpolateColor([255, 165, 0], [255, 0, 0], (normalized - 0.75) / 0.25);
        }
        
        ctx.fillStyle = `rgb(${color[0]}, ${color[1]}, ${color[2]})`;
        ctx.fillRect(x * gridSize, y * gridSize, gridSize, gridSize);
        
        // Hillshade
        if (this.showHillshade) {
          const intensity = 0.3 * (1 - normalized);
          ctx.fillStyle = `rgba(0, 0, 0, ${intensity})`;
          ctx.fillRect(x * gridSize, y * gridSize, gridSize, gridSize);
        }
      }
    }
    
    // Add contour lines
    ctx.strokeStyle = 'rgba(255, 255, 255, 0.4)';
    ctx.lineWidth = 1;
    for (let i = 1; i <= 4; i++) {
      const contourY = (i / 5) * height;
      ctx.beginPath();
      ctx.moveTo(0, contourY);
      ctx.lineTo(width, contourY);
      ctx.stroke();
      
      // Label
      ctx.fillStyle = 'white';
      ctx.font = '10px Arial';
      const elevValue = minElev + (i / 5) * elevRange;
      ctx.fillText(`${elevValue.toFixed(0)}m`, 5, contourY - 5);
    }
    
    // Title
    ctx.fillStyle = 'white';
    ctx.font = '14px Arial';
    ctx.fillText(`Digital Elevation Model - Range: ${minElev.toFixed(0)}m to ${maxElev.toFixed(0)}m`, 10, 20);
  }

  update3D() {
    const { width, height } = this.threeDCanvas;
    const ctx = this.threeDCtx;
    
    // Clear with sky gradient
    const gradient = ctx.createLinearGradient(0, 0, 0, height);
    gradient.addColorStop(0, '#87CEEB');
    gradient.addColorStop(1, '#98D8E8');
    ctx.fillStyle = gradient;
    ctx.fillRect(0, 0, width, height);
    
    if (!this.samplePoints) return;
    
    const elevs = this.samplePoints.map(p => p.elev);
    const minElev = Math.min(...elevs);
    const maxElev = Math.max(...elevs);
    const elevRange = Math.max(1, maxElev - minElev);
    
    // Convert to 3D points
    const points = this.samplePoints.map((point, i) => {
      const angle = (i / this.samplePoints.length) * Math.PI * 2;
      const radius = 0.3 * Math.min(width, height) * this.zoom;
      const x = width / 2 + Math.cos(angle + this.rotationY * Math.PI / 180) * radius;
      const y = height / 2 - ((point.elev - minElev) / elevRange) * 100 * this.zoom + 
                Math.sin(angle + this.rotationY * Math.PI / 180) * radius * 0.5;
      return { x, y, elev: point.elev };
    });
    
    // Draw terrain
    ctx.fillStyle = '#2E8B57';
    ctx.beginPath();
    ctx.moveTo(points[0].x, points[0].y);
    for (let i = 1; i < points.length; i++) {
      ctx.lineTo(points[i].x, points[i].y);
    }
    ctx.lineTo(width, height);
    ctx.lineTo(0, height);
    ctx.closePath();
    ctx.fill();
    
    // Draw terrain outline
    ctx.strokeStyle = '#1F5F3A';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(points[0].x, points[0].y);
    for (let i = 1; i < points.length; i++) {
      ctx.lineTo(points[i].x, points[i].y);
    }
    ctx.stroke();
    
    // Draw elevation markers
    points.forEach((point, i) => {
      ctx.fillStyle = '#333';
      ctx.beginPath();
      ctx.arc(point.x, point.y, 3, 0, Math.PI * 2);
      ctx.fill();
      
      // Elevation labels for some points
      if (i % Math.floor(this.samplePoints.length / 5) === 0) {
        ctx.fillStyle = '#000';
        ctx.font = '10px Arial';
        ctx.fillText(`${point.elev.toFixed(0)}m`, point.x + 5, point.y - 5);
      }
    });
    
    // Info text
    ctx.fillStyle = '#000';
    ctx.font = '12px Arial';
    ctx.fillText(`3D View • Drag to rotate • Scroll to zoom • Elevation: ${minElev.toFixed(0)}-${maxElev.toFixed(0)}m`, 10, 20);
  }

  updateFlow() {
    const { width, height } = this.flowCanvas;
    const ctx = this.flowCtx;
    
    // Clear
    ctx.fillStyle = '#1a1a1a';
    ctx.fillRect(0, 0, width, height);
    
    if (!this.samplePoints || this.samplePoints.length < 2) return;
    
    const elevs = this.samplePoints.map(p => p.elev);
    const minElev = Math.min(...elevs);
    const maxElev = Math.max(...elevs);
    const elevRange = Math.max(1, maxElev - minElev);
    
    // Draw elevation background
    const segmentWidth = width / (this.samplePoints.length - 1);
    
    for (let i = 0; i < this.samplePoints.length - 1; i++) {
      const x = i * segmentWidth;
      const elev1 = this.samplePoints[i].elev;
      const elev2 = this.samplePoints[i + 1].elev;
      
      const intensity1 = (elev1 - minElev) / elevRange;
      const intensity2 = (elev2 - minElev) / elevRange;
      
      // Elevation-based color
      const color1 = this.getElevationColor(intensity1);
      const color2 = this.getElevationColor(intensity2);
      
      const gradient = ctx.createLinearGradient(x, 0, x + segmentWidth, 0);
      gradient.addColorStop(0, color1);
      gradient.addColorStop(1, color2);
      
      ctx.fillStyle = gradient;
      ctx.fillRect(x, 0, segmentWidth, height);
    }
    
    // Draw downhill arrows
    const arrowSpacing = Math.max(1, Math.floor(this.samplePoints.length / 10));
    
    for (let i = 0; i < this.samplePoints.length - 1; i += arrowSpacing) {
      const x = (i + 0.5) * segmentWidth;
      const y = height / 2;
      
      const elev1 = this.samplePoints[i].elev;
      const elev2 = this.samplePoints[i + 1].elev;
      const slope = Math.abs(elev2 - elev1);
      
      // Determine direction and color
      const isDownhill = elev2 < elev1;
      const arrowSize = 8 + (slope / elevRange) * 15;
      const color = isDownhill ? '#d9534f' : '#5bc0de';
      
      ctx.save();
      ctx.translate(x, y);
      
      // Draw arrow
      ctx.fillStyle = color;
      ctx.beginPath();
      if (isDownhill) {
        // Downhill arrow (points right)
        ctx.moveTo(arrowSize, 0);
        ctx.lineTo(-arrowSize/2, -arrowSize/2);
        ctx.lineTo(-arrowSize/2, arrowSize/2);
      } else {
        // Uphill arrow (points left)
        ctx.moveTo(-arrowSize, 0);
        ctx.lineTo(arrowSize/2, -arrowSize/2);
        ctx.lineTo(arrowSize/2, arrowSize/2);
      }
      ctx.closePath();
      ctx.fill();
      
      // Slope indicator dot
      const dotSize = 3 + (slope / elevRange) * 6;
      ctx.fillStyle = slope > elevRange * 0.1 ? '#0066cc' : '#66cc66';
      ctx.beginPath();
      ctx.arc(0, arrowSize, dotSize, 0, Math.PI * 2);
      ctx.fill();
      
      ctx.restore();
    }
    
    // Title and info
    ctx.fillStyle = 'white';
    ctx.font = '14px Arial';
    ctx.fillText('Flow Direction Analysis', 10, 20);
    ctx.font = '11px Arial';
    ctx.fillText('Red = Downhill • Blue = Uphill • Dots show slope steepness', 10, 40);
  }

  interpolateColor(color1, color2, factor) {
    const result = color1.slice();
    for (let i = 0; i < 3; i++) {
      result[i] = Math.round(result[i] + factor * (color2[i] - color1[i]));
    }
    return result;
  }

  getElevationColor(intensity) {
    if (intensity < 0.25) return '#000080'; // Dark blue
    if (intensity < 0.5) return '#008000'; // Green
    if (intensity < 0.75) return '#FFFF00'; // Yellow
    return '#FF0000'; // Red
  }
}

// Initialize visualizer
let terrainVisualizer;

// ---------- Utilities ----------
function toFixedSafe(v, n=4){ return (typeof v === 'number')? v.toFixed(n): v; }
function haversineMeters(lat1,lon1,lat2,lon2){
  const R=6371000, to=r=>r*Math.PI/180;
  const dlat=to(lat2-lat1), dlon=to(lon2-lon1);
  const a=Math.sin(dlat/2)**2 + Math.cos(to(lat1))*Math.cos(to(lat2))*Math.sin(dlon/2)**2;
  const c=2*Math.atan2(Math.sqrt(a),Math.sqrt(1-a));
  return R*c;
}
function polygonAreaMeters(coords){
  if(coords.length<3) return 0;
  const R=6371000, to=r=>r*Math.PI/180;
  const lat0 = coords[0][0]*Math.PI/180;
  let area=0;
  for(let i=0;i<coords.length;i++){
    const j=(i+1)%coords.length;
    const x1 = R * coords[i][1]*Math.PI/180 * Math.cos(lat0);
    const y1 = R * coords[i][0]*Math.PI/180;
    const x2 = R * coords[j][1]*Math.PI/180 * Math.cos(lat0);
    const y2 = R * coords[j][0]*Math.PI/180;
    area += (x1*y2 - x2*y1);
  }
  return Math.abs(area/2);
}

// ---------- Status Messages ----------
function showStatus(message, type = 'info') {
  const statusEl = document.getElementById('statusMessage');
  statusEl.innerHTML = `<div class="${type === 'error' ? 'error' : type === 'success' ? 'success' : 'small'}">${message}</div>`;
  if (type !== 'error' && type !== 'success') {
    setTimeout(() => { statusEl.innerHTML = ''; }, 3000);
  }
}

// ---------- Map ----------
const map = L.map('map').setView([31.95,35.91], 12);
L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { attribution: '© OpenStreetMap contributors' }).addTo(map);

// drawing
const drawnItems = new L.FeatureGroup().addTo(map);
const drawControl = new L.Control.Draw({ 
  edit: { featureGroup: drawnItems },
  draw: {
    polygon: {
      allowIntersection: false,
      showArea: true
    },
    polyline: true,
    rectangle: false,
    circle: false,
    marker: false
  }
});
map.addControl(drawControl);

// geometry state
let currentGeometry = null; // {type:'line'|'polygon', coords:[[lat,lng],...]}
let samplePoints = []; // {lat,lng,elev,source}
let isDrawing = false; // Track if we're in drawing mode

// add point on map click when not drawing - FIXED: Only add points when not in drawing mode
map.on('click', e => {
  if(!isDrawing && !drawnItems.getLayers().length){
    // allow user to add standalone points only when not drawing and no existing items
    addPoint([e.latlng.lat, e.latlng.lng]);
  }
});

// Drawing events
map.on(L.Draw.Event.CREATED, function (event) {
  isDrawing = false;
  drawnItems.clearLayers();
  drawnItems.addLayer(event.layer);
  extractGeometryFromLayer(event.layer);
});

map.on(L.Draw.Event.DRAWSTART, function (event) {
  isDrawing = true;
});

map.on(L.Draw.Event.DRAWSTOP, function (event) {
  isDrawing = false;
});

map.on(L.Draw.Event.EDITSTOP, function (event) {
  const layers = drawnItems.getLayers();
  if (layers.length > 0) {
    extractGeometryFromLayer(layers[0]);
  }
});

map.on(L.Draw.Event.DELETESTART, function (event) {
  isDrawing = false;
});

map.on(L.Draw.Event.DELETESTOP, function (event) {
  currentGeometry = null;
  samplePoints = [];
  updateCoordsBox();
  document.getElementById('summary').innerHTML = 'No results yet';
  document.getElementById('tableBox').innerHTML = 'No data';
  if(window.xsChart) window.xsChart.destroy();
});

// helpers to extract geometry
function extractGeometryFromLayer(layer){
  let latlngs = layer.getLatLngs();
  // Handle different layer types
  if (layer instanceof L.Polygon) {
    // For polygons, get the first ring (exterior)
    if (Array.isArray(latlngs[0])) {
      latlngs = latlngs[0];
    }
    const coords = latlngs.map(p=>[p.lat,p.lng]);
    currentGeometry = {type: 'polygon', coords};
  } else if (layer instanceof L.Polyline) {
    const coords = latlngs.map(p=>[p.lat,p.lng]);
    currentGeometry = {type: 'line', coords};
  }
  updateCoordsBox();
}

// manual load
document.getElementById('mode').addEventListener('change', e=>{
  const m=e.target.value;
  document.getElementById('manualBlock').style.display = m==='manual' ? 'block' : 'none';
  document.getElementById('kmlBlock').style.display = m==='kml' ? 'block' : 'none';
});

// load manual
document.getElementById('btnLoadManual').addEventListener('click', ()=>{
  const text = document.getElementById('manualCoords').value.trim();
  if(!text) return alert('Paste coordinates as lat,lng per line');
  const pts = text.split(/\r?\n/).map(l=>l.trim()).filter(Boolean).map(l=>{
    const parts = l.split(',').map(x=>parseFloat(x.trim())); return [parts[0],parts[1]];
  });
  if(pts.length<2) return alert('Need at least 2 points');
  drawnItems.clearLayers();
  L.polyline(pts).addTo(drawnItems);
  map.fitBounds(pts.map(p=>[p[0],p[1]]));
  currentGeometry = {type:'line', coords: pts};
  updateCoordsBox();
});

// KML upload
document.getElementById('kmlfile').addEventListener('change', e=>{
  const f=e.target.files[0]; if(!f) return;
  const reader=new FileReader();
  reader.onload = () => {
    try{
      const kml = new DOMParser().parseFromString(reader.result, 'text/xml');
      const gj = toGeoJSON.kml(kml);
      if(!gj.features.length) return alert('No features in KML');
      // pick first LineString or Polygon
      const feat = gj.features.find(f=>f.geometry.type==='LineString' || f.geometry.type==='Polygon') || gj.features[0];
      let coords = feat.geometry.coordinates;
      if(feat.geometry.type==='Polygon') coords = coords[0];
      // convert [lng,lat] -> [lat,lng]
      coords = coords.map(c=>[c[1],c[0]]);
      drawnItems.clearLayers();
      if(feat.geometry.type==='Polygon') L.polygon(coords).addTo(drawnItems); else L.polyline(coords).addTo(drawnItems);
      map.fitBounds(coords.map(c=>[c[0],c[1]]));
      currentGeometry = { type: feat.geometry.type==='Polygon' ? 'polygon' : 'line', coords };
      updateCoordsBox();
    }catch(err){ alert('Failed to parse KML: '+err); }
  };
  reader.readAsText(f);
});

// Go to coord
document.getElementById('btnGo').addEventListener('click', ()=>{
  const v=document.getElementById('goto').value.trim(); if(!v) return;
  const p=v.split(',').map(x=>parseFloat(x.trim()));
  if(isNaN(p[0])||isNaN(p[1])) return alert('Bad coordinates');
  map.setView([p[0],p[1]], 15);
});

// clear
document.getElementById('btnClear').addEventListener('click', ()=>{
  drawnItems.clearLayers(); 
  currentGeometry = null; 
  samplePoints=[]; 
  isDrawing = false;
  document.getElementById('coordsBox').textContent='No geometry yet'; 
  document.getElementById('summary').innerHTML='No results yet'; 
  document.getElementById('tableBox').innerHTML='No data'; 
  if(window.xsChart) window.xsChart.destroy(); 
  showStatus('', 'info');
  hideVisualizations();
});

// add point function (user click)
function addPoint(latlng){
  const marker = L.circleMarker(latlng, {radius:5, color:'#0b7285'}).addTo(drawnItems);
  marker.bindPopup('Manual point<br/>' + latlng[0].toFixed(6)+','+latlng[1].toFixed(6)).openPopup();
  // append to geometry if none exists, or add as standalone polyline
  if(!currentGeometry){
    currentGeometry={type:'line', coords:[latlng]};
  } else {
    currentGeometry.coords.push(latlng);
  }
  updateCoordsBox();
}

// update coords display
function updateCoordsBox(){
  if(!currentGeometry){ document.getElementById('coordsBox').textContent='No geometry yet'; return; }
  const lines = currentGeometry.coords.map(c=>`${c[0].toFixed(6)}, ${c[1].toFixed(6)}`);
  document.getElementById('coordsBox').textContent = `${currentGeometry.type.toUpperCase()} • ${currentGeometry.coords.length} pts\n` + lines.join('\n');
}

// ---------- Visualization Management ----------
function initializeVisualizations() {
  terrainVisualizer = new TerrainVisualizer();
}

function showVisualizations() {
  document.getElementById('vizPanel').style.display = 'block';
}

function hideVisualizations() {
  document.getElementById('vizPanel').style.display = 'none';
}

function updateVisualizations(samplePoints) {
  if (terrainVisualizer && samplePoints && samplePoints.length > 0) {
    terrainVisualizer.updateAll(samplePoints);
  }
}

// ---------- Sampling & Elevation ----------
async function analyze(){
  if(!currentGeometry || currentGeometry.coords.length<2) return alert('Draw or load coordinates first');
  
  const step = Math.max(1, parseFloat(document.getElementById('sampleDist').value) || 50);
  const source = document.getElementById('elevSource').value;
  
  showStatus(`Starting analysis with ${source}...`, 'info');
  
  // sample along polyline (for polygon use its exterior perimeter as polyline)
  let poly = currentGeometry.coords.slice();
  if(currentGeometry.type === 'polygon'){
    // ensure closed
    if(poly[0][0] !== poly[poly.length-1][0] || poly[0][1] !== poly[poly.length-1][1]) poly.push(poly[0]);
  }
  
  const samples = resamplePolyline(poly, step); // [{lat,lng}]
  showStatus(`Sampled ${samples.length} points. Fetching elevations...`, 'info');
  
  // fetch elevations with automatic fallback if no elevation variation detected
  let elevs = await fetchElevationsWithFallback(samples, source);
  
  if(!elevs){ 
    showStatus('All elevation services failed. Please try again later or use different coordinates.', 'error');
    return; 
  }
  
  showStatus('Elevation data loaded successfully! Calculating slopes...', 'success');
  
  // merge
  samplePoints = samples.map((s,i)=>({lat:s[0], lng:s[1], elev: elevs[i], source}));
  
  // compute slopes & distances
  const pairs = [];
  for(let i=0;i<samplePoints.length-1;i++){
    const a=samplePoints[i], b=samplePoints[i+1];
    const d = haversineMeters(a.lat,a.lng,b.lat,b.lng);
    const dz = b.elev - a.elev;
    const slope = d>0 ? Math.abs(dz)/d : 0; // absolute (no minuses)
    pairs.push({i, i1:i+1, dist:d, dz:dz, slope: slope, from:[a.lat,a.lng], to:[b.lat,b.lng]});
  }
  
  // compute pairwise slopes (all possible pairs)
  const pairwise = [];
  for(let i=0;i<samplePoints.length;i++){
    for(let j=i+1;j<samplePoints.length;j++){
      const a=samplePoints[i], b=samplePoints[j];
      const d = haversineMeters(a.lat,a.lng,b.lat,b.lng);
      const dz = b.elev - a.elev;
      const slope = d>0 ? Math.abs(dz)/d : 0;
      pairwise.push({i,j,dist:d,dz, slope});
    }
  }
  
  // general slope of area: (max elev - min elev) / max horizontal distance among samples
  const elevsOnly = samplePoints.map(p=>p.elev);
  const maxElev = Math.max(...elevsOnly);
  const minElev = Math.min(...elevsOnly);
  let maxDist = 0;
  for(let i=0;i<samplePoints.length;i++){
    for(let j=i+1;j<samplePoints.length;j++){
      const d = haversineMeters(samplePoints[i].lat,samplePoints[i].lng, samplePoints[j].lat,samplePoints[j].lng);
      if(d>maxDist) maxDist = d;
    }
  }
  const generalSlope = maxDist>0 ? Math.abs(maxElev-minElev)/maxDist : 0;
  
  // area (if polygon)
  let area = 0;
  if(currentGeometry.type==='polygon'){
    // use vertices without the closing repeated point
    let polyCoords = currentGeometry.coords.slice();
    if(polyCoords[0][0] === polyCoords[polyCoords.length-1][0] && polyCoords[0][1] === polyCoords[polyCoords.length-1][1]) polyCoords = polyCoords.slice(0,-1);
    area = polygonAreaMeters(polyCoords);
  }

  // render results
  renderResults({pairs, pairwise, generalSlope, maxElev, minElev, maxDist, area});
  renderChart(samplePoints);
  renderMapSamples();
  
  // NEW: Show and update visualizations
  showVisualizations();
  initializeVisualizations();
  updateVisualizations(samplePoints);
  
  showStatus('Analysis complete!', 'success');
  setTimeout(() => showStatus('', 'info'), 3000);
}

// Smart elevation fetching with automatic fallback
async function fetchElevationsWithFallback(samples, primarySource) {
  let elevs = await fetchElevations(samples, primarySource);
  
  // Check if we got valid elevation data with variation
  if (elevs && hasElevationVariation(elevs)) {
    return elevs;
  }
  
  // If primary source failed or has no variation, try fallbacks
  const fallbackOrder = getFallbackOrder(primarySource);
  
  for (const fallbackSource of fallbackOrder) {
    showStatus(`${primarySource} failed or no elevation variation. Trying ${fallbackSource}...`, 'error');
    elevs = await fetchElevations(samples, fallbackSource);
    
    if (elevs && hasElevationVariation(elevs)) {
      showStatus(`Successfully used ${fallbackSource} as fallback`, 'success');
      return elevs;
    }
  }
  
  // If all sources fail but we have some data, return it with warning
  if (elevs) {
    showStatus('Warning: All elevation sources show minimal variation. Data may be inaccurate.', 'error');
    return elevs;
  }
  
  return null;
}

// Check if elevation data has meaningful variation
function hasElevationVariation(elevs) {
  if (!elevs || elevs.length === 0) return false;
  
  const uniqueElevations = [...new Set(elevs.map(e => Math.round(e * 10)))];
  const elevationRange = Math.max(...elevs) - Math.min(...elevs);
  
  // Consider it valid if we have at least 2 different elevation values 
  // OR significant elevation range (> 1 meter)
  return uniqueElevations.length > 1 || elevationRange > 1;
}

// Define fallback order based on primary source
function getFallbackOrder(primarySource) {
  const allSources = [
    'opentopodata',
    'opentopodata-aster', 
    'airbus-elevation',
    'open-elevation',
    'nationalmap-usgs'
  ];
  
  // Remove primary source from the list
  const fallbacks = allSources.filter(source => source !== primarySource);
  
  // Reorder based on reliability
  const priorityOrder = [
    'opentopodata',
    'opentopodata-aster',
    'airbus-elevation', 
    'open-elevation',
    'nationalmap-usgs'
  ];
  
  // Sort fallbacks by priority order
  return fallbacks.sort((a, b) => {
    return priorityOrder.indexOf(a) - priorityOrder.indexOf(b);
  });
}

// resample polyline with approx spacing (meters)
function resamplePolyline(latlngs, stepM){
  const out = [];
  for(let i=0;i<latlngs.length-1;i++){
    const a = latlngs[i], b = latlngs[i+1];
    const seg = haversineMeters(a[0],a[1],b[0],b[1]);
    const n = Math.max(1, Math.ceil(seg/stepM));
    for(let j=0;j<n;j++){
      const t = j/n;
      const lat = a[0] + (b[0]-a[0])*t;
      const lng = a[1] + (b[1]-a[1])*t;
      out.push([lat,lng]);
    }
  }
  out.push(latlngs[latlngs.length-1]); // last
  return out;
}

// elevation fetch with new services
async function fetchElevations(samples, source){
  try{
    const results = [];
    const batchSize = 50;
    let dataset = 'srtm90m';
    
    if(source === 'opentopodata-aster') {
      dataset = 'aster30m';
    }
    
    for(let i=0;i<samples.length;i+=batchSize){
      const chunk = samples.slice(i,i+batchSize);
      const locations = chunk.map(p=>`${p[0]},${p[1]}`).join('|');
      
      let url;
      if(source.startsWith('opentopodata')){
        url = `https://api.opentopodata.org/v1/${dataset}?locations=${encodeURIComponent(locations)}`;
      } else if (source === 'airbus-elevation') {
        // Airbus Elevation API - free, no key needed
        const points = chunk.map(p => ({ lat: p[0], lon: p[1] }));
        const response = await fetch('https://elevation.airbus.com/api/elevation', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ points: points })
        });
        
        if (!response.ok) throw new Error(`Airbus API error: ${response.status}`);
        const data = await response.json();
        
        if (data.elevations && Array.isArray(data.elevations)) {
          results.push(...data.elevations);
        } else {
          throw new Error('Airbus API: Invalid response format');
        }
        
        // Continue to next batch
        await new Promise(res=>setTimeout(res, 500));
        continue;
      } else if (source === 'nationalmap-usgs') {
        // USGS National Map Elevation API (US only)
        const locationsUSGS = chunk.map(p => `${p[1]},${p[0]}`).join(',');
        url = `https://epqs.nationalmap.gov/v1/json?x=${locationsUSGS}&units=Meters&output=json`;
      } else {
        // Open-Elevation
        url = `https://api.open-elevation.com/api/v1/lookup?locations=${encodeURIComponent(locations)}`;
      }
      
      showStatus(`Fetching elevations ${i+1}-${Math.min(i+batchSize, samples.length)}/${samples.length} from ${source}...`, 'info');
      
      // Skip fetch for Airbus since we already handled it
      if (source !== 'airbus-elevation') {
        const resp = await fetch(url);
        if(!resp.ok) {
          const errorText = await resp.text();
          console.error(`${source} error:`, resp.status, errorText);
          
          // Check for rate limiting
          if(resp.status === 429) {
            showStatus('Rate limit exceeded. Waiting before retry...', 'error');
            await new Promise(res=>setTimeout(res, 2000));
            // Try one more time
            const retryResp = await fetch(url);
            if(!retryResp.ok) {
              throw new Error(`Rate limit persists: ${retryResp.status}`);
            }
            const retryJs = await retryResp.json();
            processElevationResponse(retryJs, results, source);
          } else {
            throw new Error(`${source} error ${resp.status}: ${errorText}`);
          }
        } else {
          const js = await resp.json();
          processElevationResponse(js, results, source);
        }
      }
      
      // Increased delay to reduce rate issues
      await new Promise(res=>setTimeout(res, 800));
    }
    
    // Final validation
    if (results.length !== samples.length) {
      throw new Error(`Expected ${samples.length} elevations but got ${results.length}`);
    }
    
    return results;
  }catch(err){
    console.error('Elevation fetch failed:', err);
    showStatus(`Elevation fetch from ${source} failed: ${err.message}`, 'error');
    return null;
  }
}

// Helper function to process elevation responses from different APIs
function processElevationResponse(js, results, source) {
  if (source === 'nationalmap-usgs') {
    // USGS response format
    if (js && js.USGS_Elevation_Point_Query_Service && js.USGS_Elevation_Point_Query_Service.Elevation_Query) {
      js.USGS_Elevation_Point_Query_Service.Elevation_Query.forEach(r => {
        results.push(r.Elevation !== null && r.Elevation !== undefined ? r.Elevation : 0);
      });
    } else {
      throw new Error('USGS: Invalid response format');
    }
  } else if (source.startsWith('opentopodata')) {
    // OpenTopoData response format
    if (!js.results) throw new Error(`${source}: no results`);
    js.results.forEach(r => {
      results.push(r.elevation !== null && r.elevation !== undefined ? r.elevation : 0);
    });
  } else if (source === 'open-elevation') {
    // Open-Elevation response format
    if (!js.results) throw new Error(`${source}: no results`);
    js.results.forEach(r => {
      results.push(r.elevation !== null && r.elevation !== undefined ? r.elevation : 0);
    });
  }
}

// render map sample markers and line
let sampleLayer = L.layerGroup().addTo(map);
function renderMapSamples(){
  sampleLayer.clearLayers();
  if(samplePoints.length===0) return;
  const latlngs = samplePoints.map(p=>[p.lat,p.lng]);
  L.polyline(latlngs, {color:'#d9534f', weight:3}).addTo(sampleLayer);
  samplePoints.forEach((p,i)=>{
    const m = L.circleMarker([p.lat,p.lng], {radius:4, color:'#0b7285'}).addTo(sampleLayer);
    m.bindPopup(`pt ${i+1}<br/>elev: ${p.elev} m<br/>source: ${p.source}`);
  });
  map.fitBounds(latlngs);
}

// render chart
let xsChart = null;
function renderChart(points){
  const dists = [0];
  for(let i=1;i<points.length;i++){
    const d = haversineMeters(points[i-1].lat,points[i-1].lng,points[i].lat,points[i].lng);
    dists.push(dists[i-1] + d);
  }
  const labels = dists.map(d=>d.toFixed(1));
  const elevs = points.map(p=>p.elev);
  const ctx = document.getElementById('xsChart').getContext('2d');
  if(xsChart) xsChart.destroy();
  xsChart = new Chart(ctx, {
    type:'line',
    data:{
      labels: labels,
      datasets:[{label:'Elevation (m)', data:elevs, fill:true, tension:0.2}]
    },
    options:{
      plugins:{legend:{display:false}},
      scales:{ x: { title:{display:true,text:'Distance (m)'} }, y: { title:{display:true,text:'Elevation (m)'} } }
    }
  });
  window.xsChart = xsChart;
}

// render results table/summary
function renderResults(obj){
  const {pairs, pairwise, generalSlope, maxElev, minElev, maxDist, area} = obj;
  const avgAdjacentSlope = pairs.length ? (pairs.reduce((a,b)=>a + Math.abs(b.slope),0)/pairs.length) : 0;
  const maxPairwise = pairwise.length ? pairwise.reduce((a,b)=> b.slope>a.slope?b:a ) : null;
  const summaryEl = document.getElementById('summary');
  summaryEl.innerHTML = `
    <div><b>Sample points:</b> ${samplePoints.length}</div>
    <div><b>Area:</b> ${area? (area.toFixed(1)+' m² ('+(area/10000).toFixed(3)+' ha)') : 'N/A (not polygon)'}</div>
    <div><b>Elevation range:</b> ${minElev} m — ${maxElev} m (Δ ${ (maxElev-minElev).toFixed(2)} m)</div>
    <div><b>General slope (max Δe / max horizontal distance):</b> ${generalSlope.toFixed(5)} m/m (${(generalSlope*100).toFixed(2)} %)</div>
    <div><b>Average adjacent slope:</b> ${avgAdjacentSlope.toFixed(5)} m/m (${(avgAdjacentSlope*100).toFixed(2)} %)</div>
    <div><b>Max pairwise slope:</b> ${maxPairwise ? maxPairwise.slope.toFixed(5)+' m/m ('+(maxPairwise.slope*100).toFixed(2)+' %) between pts '+maxPairwise.i+' & '+maxPairwise.j : 'N/A'}</div>
    <div class="small" style="margin-top:6px">All slope values are <b>absolute</b> (no negative values). Distances use haversine (approx.). Elevation source shown per point.</div>
  `;

  // table of adjacent segments
  const tbl = document.createElement('table');
  tbl.innerHTML = `<thead><tr><th>#</th><th>From (lat,lng)</th><th>To (lat,lng)</th><th>Dist (m)</th><th>Δz (m)</th><th>Slope (m/m)</th></tr></thead>`;
  const tbody = document.createElement('tbody');
  pairs.forEach((p,idx)=>{
    const r = document.createElement('tr');
    r.innerHTML = `<td>${idx+1}</td>
      <td>${p.from[0].toFixed(6)}, ${p.from[1].toFixed(6)}</td>
      <td>${p.to[0].toFixed(6)}, ${p.to[1].toFixed(6)}</td>
      <td>${p.dist.toFixed(1)}</td>
      <td>${p.dz.toFixed(2)}</td>
      <td>${p.slope.toFixed(5)}</td>`;
    tbody.appendChild(r);
  });
  tbl.appendChild(tbody);
  const box = document.getElementById('tableBox');
  box.innerHTML = '';
  box.appendChild(tbl);
}

// export CSV
document.getElementById('btnExportCSV').addEventListener('click', ()=>{
  if(!samplePoints.length) return alert('No samples to export');
  let csv = 'index,lat,lng,elevation_m,source\n';
  samplePoints.forEach((p,i)=> csv += `${i+1},${p.lat},${p.lng},${p.elev},${p.source}\n`);
  // also append adjacent pairs
  csv += '\nseg_index,from_idx,to_idx,dist_m,dz_m,slope_m_per_m\n';
  const pairs = [];
  for(let i=0;i<samplePoints.length-1;i++){
    const a=samplePoints[i], b=samplePoints[i+1];
    const d = haversineMeters(a.lat,a.lng,b.lat,b.lng);
    const dz = b.elev - a.elev;
    const slope = d>0? Math.abs(dz)/d : 0;
    csv += `${i+1},${i+1},${i+2},${d.toFixed(2)},${dz.toFixed(3)},${slope.toFixed(6)}\n`;
  }
  const blob = new Blob([csv], {type:'text/csv'});
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a'); a.href=url; a.download='slope_results.csv'; document.body.appendChild(a); a.click(); a.remove(); setTimeout(()=>URL.revokeObjectURL(url),2000);
});

// ---------- UI wiring ----------
document.getElementById('btnAnalyze').addEventListener('click', analyze);

// For convenience: double click map to add point and update geometry
map.on('dblclick', e=>{
  if(!isDrawing) {
    addPoint([e.latlng.lat, e.latlng.lng]);
  }
});

// Tab switching
document.querySelectorAll('.viz-tab').forEach(tab => {
  tab.addEventListener('click', () => {
    document.querySelectorAll('.viz-tab').forEach(t => t.classList.remove('active'));
    document.querySelectorAll('.viz-content').forEach(c => c.classList.remove('active'));
    tab.classList.add('active');
    document.getElementById(tab.dataset.viz + 'Viz').classList.add('active');
    
    // Update the active visualization
    if (terrainVisualizer && samplePoints && samplePoints.length > 0) {
      setTimeout(() => terrainVisualizer.updateAll(samplePoints), 100);
    }
  });
});

// Initialize when page loads
document.addEventListener('DOMContentLoaded', function() {
  initializeVisualizations();
  hideVisualizations();
});

// show click on sample to view more -> handled by popups when rendering
// initial message
updateCoordsBox();

</script>
</body>
</html>
