<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Slope Analyzer — Omar Yaseen</title>

<!-- CSS -->
<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet.draw/1.0.4/leaflet.draw.css"/>
<style>
  :root{--accent:#0b7285;--bg:#f6fbfd}
  body{margin:0;font-family:Inter,Arial,Helvetica;background:var(--bg);color:#111}
  header{background:linear-gradient(90deg,#0b7285,#66c2ff);color:white;padding:12px 14px}
  header h1{margin:0;font-size:17px}
  .wrap{display:grid;grid-template-columns:1fr 400px;gap:12px;padding:12px}
  @media(max-width:920px){.wrap{grid-template-columns:1fr;}}
  #map{height:560px;border-radius:8px;box-shadow:0 6px 18px rgba(0,0,0,0.08)}
  .panel{background:#fff;padding:12px;border-radius:10px;box-shadow:0 6px 18px rgba(12,20,24,0.06)}
  label{display:block;font-weight:600;margin-top:8px}
  input,textarea,select,button{width:100%;padding:8px;margin-top:6px;border-radius:8px;border:1px solid #d8e2e8}
  textarea{min-height:84px;font-family:monospace}
  .coords{font-family:monospace;font-size:13px;color:#445;white-space:pre-wrap;max-height:160px;overflow:auto}
  table{width:100%;border-collapse:collapse;font-size:13px}
  th,td{padding:6px;border:1px solid #eef}
  .small{font-size:13px;color:#556}
  .row{display:flex;gap:8px}
  .row > *{flex:1}
  .muted{color:#6b7}
  #xsChart{width:100%;height:220px}
  footer{text-align:center;padding:10px;color:#333}
  a.link{color:var(--accent);text-decoration:none}
  .error{color:#d9534f;background:#fdf2f2;padding:8px;border-radius:4px;margin:8px 0}
  .success{color:#2e7d32;background:#f2fdf2;padding:8px;border-radius:4px;margin:8px 0}
  
  /* New styles for visualizations */
  .viz-container {margin-top:12px; display:none;}
  .viz-tabs {display:flex; gap:8px; margin-bottom:12px;}
  .viz-tab {padding:8px 16px; background:#f0f0f0; border-radius:6px; cursor:pointer; border:none; font-size:13px;}
  .viz-tab.active {background:var(--accent); color:white;}
  .viz-content {display:none;}
  .viz-content.active {display:block;}
  #demCanvas, #flowCanvas {width:100%; height:300px; background:#f8f9fa; border-radius:8px;}
  #threeDContainer {width:100%; height:300px; background:#f8f9fa; border-radius:8px; position:relative;}
  #threeDView {width:100%; height:100%;}
  .viz-controls {margin-top:8px; display:flex; gap:8px; flex-wrap:wrap;}
  .viz-controls button {flex:1; min-width:120px;}
  .downhill-arrow {position:absolute; width:0; height:0; border-left:6px solid transparent; border-right:6px solid transparent; border-top:12px solid #d9534f; transform-origin:center;}
</style>
</head>
<body>
<header>
  <h1>Slope Analyzer — draw / upload / paste • Cross-section & slopes</h1>
  <div class="small">Map: OpenStreetMap • Elevation: OpenTopoData (SRTM) or Open-Elevation. Calculations shown with sources.</div>
</header>

<div class="wrap">
  <!-- left: map + chart -->
  <div>
    <div id="map" class="panel"></div>

    <div class="panel" style="margin-top:12px">
      <h3>Cross-section</h3>
      <canvas id="xsChart"></canvas>
    </div>

    <!-- NEW: Visualizations Panel -->
    <div class="panel viz-container" style="margin-top:12px" id="vizPanel">
      <h3>3D Visualization & Analysis</h3>
      <div class="viz-tabs">
        <button class="viz-tab active" data-viz="dem">DEM View</button>
        <button class="viz-tab" data-viz="threed">3D View</button>
        <button class="viz-tab" data-viz="flow">Flow Direction</button>
      </div>
      
      <div class="viz-content active" id="demViz">
        <canvas id="demCanvas"></canvas>
        <div class="viz-controls">
          <button id="btnExportDEM">Export DEM Image</button>
          <button id="btnToggleHillshade">Toggle Hillshade</button>
        </div>
      </div>
      
      <div class="viz-content" id="threedViz">
        <div id="threeDContainer">
          <canvas id="threeDView"></canvas>
        </div>
        <div class="viz-controls">
          <button id="btnRotate3D">Rotate View</button>
          <button id="btnReset3D">Reset View</button>
          <button id="btnExport3D">Export 3D Image</button>
        </div>
      </div>
      
      <div class="viz-content" id="flowViz">
        <canvas id="flowCanvas"></canvas>
        <div class="viz-controls">
          <button id="btnExportFlow">Export Flow Map</button>
          <button id="btnToggleArrows">Toggle Arrows</button>
        </div>
        <div class="small" style="margin-top:8px">
          Red arrows show downhill direction. Arrow size indicates slope steepness.
        </div>
      </div>
    </div>

    <div class="panel" style="margin-top:12px">
      <h3>Export</h3>
      <div class="small">Download a CSV of the computed points/segments</div>
      <button id="btnExportCSV">Export CSV</button>
      <div class="small" style="margin-top:8px">Open locally? Use Firefox or run a tiny server:
        <code>python -m http.server 8000</code>
      </div>
    </div>
  </div>

  <!-- right: controls & results -->
  <aside>
    <div class="panel">
      <h3>Inputs & Controls</h3>

      <label>Mode</label>
      <select id="mode">
        <option value="draw">Draw polygon / line (use draw tools)</option>
        <option value="manual">Manual coordinates (lat,lng per line)</option>
        <option value="kml">Upload KML (Polygon or LineString)</option>
      </select>

      <div id="drawBlock" style="margin-top:8px">
        <div class="small">Use the drawing control on the map to draw polygon or line. Click map to add points when not drawing.</div>
      </div>

      <div id="manualBlock" style="display:none">
        <label>Manual coordinates (lat,lng per line)</label>
        <textarea id="manualCoords" placeholder="31.95,35.91"></textarea>
        <button id="btnLoadManual">Load Coordinates</button>
      </div>

      <div id="kmlBlock" style="display:none">
        <label>Upload KML</label>
        <input type="file" id="kmlfile" accept=".kml"/>
      </div>

      <label>Go to coordinates (lat,lng)</label>
      <div class="row">
        <input id="goto" placeholder="31.95,35.91"/>
        <button id="btnGo">Go</button>
      </div>

      <label>Sampling distance along line (m)</label>
      <input id="sampleDist" type="number" value="50"/>

      <label>Elevation source (batch)</label>
      <select id="elevSource">
        <option value="opentopodata">OpenTopoData (SRTM) — recommended</option>
        <option value="opentopodata-aster">OpenTopoData (ASTER) — alternative</option>
        <option value="open-elevation">Open-Elevation (public)</option>
        <option value="airbus-elevation">Airbus Elevation API (Free)</option>
        <option value="nationalmap-usgs">USGS National Map (US only)</option>
      </select>

      <div id="statusMessage"></div>

      <div class="row" style="margin-top:8px">
        <button id="btnClear">Clear</button>
        <button id="btnAnalyze">Analyze</button>
      </div>

      <label style="margin-top:10px">Map coordinates / actions</label>
      <div class="small">Tap the map to add a point (or draw). Click a sample marker to see elev & source.</div>
      <div class="coords" id="coordsBox">No geometry yet</div>
    </div>

    <div class="panel" style="margin-top:12px">
      <h3>Summary Results</h3>
      <div id="summary">No results yet</div>
    </div>

    <div class="panel" style="margin-top:12px">
      <h3>Detailed table</h3>
      <div id="tableBox">No data</div>
    </div>

    <div class="panel" style="margin-top:12px">
      <h4>Sources & credits</h4>
      <div class="small">
        Map tiles: OpenStreetMap contributors. Elevation: chosen source (OpenTopoData or Open-Elevation). Calculations performed client-side (haversine distances, shoelace area).<br/>
        Made by <a class="link" href="https://www.linkedin.com/in/omaryaseen" target="_blank">Omar Yaseen</a>.
      </div>
    </div>
  </aside>
</div>

<footer>
  <div class="small">Tip: If opening from a local file causes issues on Android, open in Firefox or serve via a tiny web server.</div>
</footer>

<!-- libs -->
<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet.draw/1.0.4/leaflet.draw.js"></script>
<script src="https://cdn.jsdelivr.net/npm/togeojson@0.16.0/dist/togeojson.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

<script>
// ---------- Utilities ----------
function toFixedSafe(v, n=4){ return (typeof v === 'number')? v.toFixed(n): v; }
function haversineMeters(lat1,lon1,lat2,lon2){
  const R=6371000, to=r=>r*Math.PI/180;
  const dlat=to(lat2-lat1), dlon=to(lon2-lon1);
  const a=Math.sin(dlat/2)**2 + Math.cos(to(lat1))*Math.cos(to(lat2))*Math.sin(dlon/2)**2;
  const c=2*Math.atan2(Math.sqrt(a),Math.sqrt(1-a));
  return R*c;
}
function polygonAreaMeters(coords){
  // coords: [ [lat,lng], ... ] (closed or not)
  // convert to projected XY approx via simple equirectangular projection (accurate enough for moderate extents)
  if(coords.length<3) return 0;
  const R=6371000, to=r=>r*Math.PI/180;
  const lat0 = coords[0][0]*Math.PI/180;
  let area=0;
  for(let i=0;i<coords.length;i++){
    const j=(i+1)%coords.length;
    const x1 = R * coords[i][1]*Math.PI/180 * Math.cos(lat0);
    const y1 = R * coords[i][0]*Math.PI/180;
    const x2 = R * coords[j][1]*Math.PI/180 * Math.cos(lat0);
    const y2 = R * coords[j][0]*Math.PI/180;
    area += (x1*y2 - x2*y1);
  }
  return Math.abs(area/2);
}

// ---------- Status Messages ----------
function showStatus(message, type = 'info') {
  const statusEl = document.getElementById('statusMessage');
  statusEl.innerHTML = `<div class="${type === 'error' ? 'error' : type === 'success' ? 'success' : 'small'}">${message}</div>`;
  if (type !== 'error' && type !== 'success') {
    setTimeout(() => { statusEl.innerHTML = ''; }, 3000);
  }
}

// ---------- Map ----------
const map = L.map('map').setView([31.95,35.91], 12);
L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { attribution: '© OpenStreetMap contributors' }).addTo(map);

// drawing
const drawnItems = new L.FeatureGroup().addTo(map);
const drawControl = new L.Control.Draw({ 
  edit: { featureGroup: drawnItems },
  draw: {
    polygon: {
      allowIntersection: false,
      showArea: true
    },
    polyline: true,
    rectangle: false,
    circle: false,
    marker: false
  }
});
map.addControl(drawControl);

// geometry state
let currentGeometry = null; // {type:'line'|'polygon', coords:[[lat,lng],...]}
let samplePoints = []; // {lat,lng,elev,source}
let isDrawing = false; // Track if we're in drawing mode

// add point on map click when not drawing - FIXED: Only add points when not in drawing mode
map.on('click', e => {
  if(!isDrawing && !drawnItems.getLayers().length){
    // allow user to add standalone points only when not drawing and no existing items
    addPoint([e.latlng.lat, e.latlng.lng]);
  }
});

// Drawing events
map.on(L.Draw.Event.CREATED, function (event) {
  isDrawing = false;
  drawnItems.clearLayers();
  drawnItems.addLayer(event.layer);
  extractGeometryFromLayer(event.layer);
});

map.on(L.Draw.Event.DRAWSTART, function (event) {
  isDrawing = true;
});

map.on(L.Draw.Event.DRAWSTOP, function (event) {
  isDrawing = false;
});

map.on(L.Draw.Event.EDITSTOP, function (event) {
  const layers = drawnItems.getLayers();
  if (layers.length > 0) {
    extractGeometryFromLayer(layers[0]);
  }
});

map.on(L.Draw.Event.DELETESTART, function (event) {
  isDrawing = false;
});

map.on(L.Draw.Event.DELETESTOP, function (event) {
  currentGeometry = null;
  samplePoints = [];
  updateCoordsBox();
  document.getElementById('summary').innerHTML = 'No results yet';
  document.getElementById('tableBox').innerHTML = 'No data';
  if(window.xsChart) window.xsChart.destroy();
});

// helpers to extract geometry
function extractGeometryFromLayer(layer){
  let latlngs = layer.getLatLngs();
  // Handle different layer types
  if (layer instanceof L.Polygon) {
    // For polygons, get the first ring (exterior)
    if (Array.isArray(latlngs[0])) {
      latlngs = latlngs[0];
    }
    const coords = latlngs.map(p=>[p.lat,p.lng]);
    currentGeometry = {type: 'polygon', coords};
  } else if (layer instanceof L.Polyline) {
    const coords = latlngs.map(p=>[p.lat,p.lng]);
    currentGeometry = {type: 'line', coords};
  }
  updateCoordsBox();
}

// manual load
document.getElementById('mode').addEventListener('change', e=>{
  const m=e.target.value;
  document.getElementById('manualBlock').style.display = m==='manual' ? 'block' : 'none';
  document.getElementById('kmlBlock').style.display = m==='kml' ? 'block' : 'none';
});

// load manual
document.getElementById('btnLoadManual').addEventListener('click', ()=>{
  const text = document.getElementById('manualCoords').value.trim();
  if(!text) return alert('Paste coordinates as lat,lng per line');
  const pts = text.split(/\r?\n/).map(l=>l.trim()).filter(Boolean).map(l=>{
    const parts = l.split(',').map(x=>parseFloat(x.trim())); return [parts[0],parts[1]];
  });
  if(pts.length<2) return alert('Need at least 2 points');
  drawnItems.clearLayers();
  L.polyline(pts).addTo(drawnItems);
  map.fitBounds(pts.map(p=>[p[0],p[1]]));
  currentGeometry = {type:'line', coords: pts};
  updateCoordsBox();
});

// KML upload
document.getElementById('kmlfile').addEventListener('change', e=>{
  const f=e.target.files[0]; if(!f) return;
  const reader=new FileReader();
  reader.onload = () => {
    try{
      const kml = new DOMParser().parseFromString(reader.result, 'text/xml');
      const gj = toGeoJSON.kml(kml);
      if(!gj.features.length) return alert('No features in KML');
      // pick first LineString or Polygon
      const feat = gj.features.find(f=>f.geometry.type==='LineString' || f.geometry.type==='Polygon') || gj.features[0];
      let coords = feat.geometry.coordinates;
      if(feat.geometry.type==='Polygon') coords = coords[0];
      // convert [lng,lat] -> [lat,lng]
      coords = coords.map(c=>[c[1],c[0]]);
      drawnItems.clearLayers();
      if(feat.geometry.type==='Polygon') L.polygon(coords).addTo(drawnItems); else L.polyline(coords).addTo(drawnItems);
      map.fitBounds(coords.map(c=>[c[0],c[1]]));
      currentGeometry = { type: feat.geometry.type==='Polygon' ? 'polygon' : 'line', coords };
      updateCoordsBox();
    }catch(err){ alert('Failed to parse KML: '+err); }
  };
  reader.readAsText(f);
});

// Go to coord
document.getElementById('btnGo').addEventListener('click', ()=>{
  const v=document.getElementById('goto').value.trim(); if(!v) return;
  const p=v.split(',').map(x=>parseFloat(x.trim()));
  if(isNaN(p[0])||isNaN(p[1])) return alert('Bad coordinates');
  map.setView([p[0],p[1]], 15);
});

// clear
document.getElementById('btnClear').addEventListener('click', ()=>{
  drawnItems.clearLayers(); 
  currentGeometry = null; 
  samplePoints=[]; 
  isDrawing = false;
  document.getElementById('coordsBox').textContent='No geometry yet'; 
  document.getElementById('summary').innerHTML='No results yet'; 
  document.getElementById('tableBox').innerHTML='No data'; 
  if(window.xsChart) window.xsChart.destroy(); 
  showStatus('', 'info');
  hideVisualizations();
});

// add point function (user click)
function addPoint(latlng){
  const marker = L.circleMarker(latlng, {radius:5, color:'#0b7285'}).addTo(drawnItems);
  marker.bindPopup('Manual point<br/>' + latlng[0].toFixed(6)+','+latlng[1].toFixed(6)).openPopup();
  // append to geometry if none exists, or add as standalone polyline
  if(!currentGeometry){
    currentGeometry={type:'line', coords:[latlng]};
  } else {
    currentGeometry.coords.push(latlng);
  }
  updateCoordsBox();
}

// update coords display
function updateCoordsBox(){
  if(!currentGeometry){ document.getElementById('coordsBox').textContent='No geometry yet'; return; }
  const lines = currentGeometry.coords.map(c=>`${c[0].toFixed(6)}, ${c[1].toFixed(6)}`);
  document.getElementById('coordsBox').textContent = `${currentGeometry.type.toUpperCase()} • ${currentGeometry.coords.length} pts\n` + lines.join('\n');
}

// ---------- NEW: Visualization Functions ----------
let demCanvas, demCtx, flowCanvas, flowCtx, threeDCanvas, threeDCtx;
let showHillshade = true;
let showArrows = true;
let threeDRotation = 0;

function initializeVisualizations() {
  // Initialize canvases
  demCanvas = document.getElementById('demCanvas');
  demCtx = demCanvas.getContext('2d');
  flowCanvas = document.getElementById('flowCanvas');
  flowCtx = flowCanvas.getContext('2d');
  threeDCanvas = document.getElementById('threeDView');
  threeDCtx = threeDCanvas.getContext('2d');
  
  // Set canvas sizes
  const setCanvasSize = (canvas) => {
    canvas.width = canvas.offsetWidth;
    canvas.height = canvas.offsetHeight;
  };
  
  setCanvasSize(demCanvas);
  setCanvasSize(flowCanvas);
  setCanvasSize(threeDCanvas);
  
  // Tab switching
  document.querySelectorAll('.viz-tab').forEach(tab => {
    tab.addEventListener('click', () => {
      document.querySelectorAll('.viz-tab').forEach(t => t.classList.remove('active'));
      document.querySelectorAll('.viz-content').forEach(c => c.classList.remove('active'));
      tab.classList.add('active');
      document.getElementById(tab.dataset.viz + 'Viz').classList.add('active');
      updateVisualizations();
    });
  });
  
  // Control buttons
  document.getElementById('btnToggleHillshade').addEventListener('click', () => {
    showHillshade = !showHillshade;
    updateDEMVisualization();
  });
  
  document.getElementById('btnToggleArrows').addEventListener('click', () => {
    showArrows = !showArrows;
    updateFlowVisualization();
  });
  
  document.getElementById('btnRotate3D').addEventListener('click', () => {
    threeDRotation += 45;
    if (threeDRotation >= 360) threeDRotation = 0;
    update3DVisualization();
  });
  
  document.getElementById('btnReset3D').addEventListener('click', () => {
    threeDRotation = 0;
    update3DVisualization();
  });
  
  // Export buttons
  document.getElementById('btnExportDEM').addEventListener('click', exportDEM);
  document.getElementById('btnExport3D').addEventListener('click', export3D);
  document.getElementById('btnExportFlow').addEventListener('click', exportFlow);
}

function showVisualizations() {
  document.getElementById('vizPanel').style.display = 'block';
}

function hideVisualizations() {
  document.getElementById('vizPanel').style.display = 'none';
}

function updateVisualizations() {
  if (samplePoints.length === 0) return;
  
  updateDEMVisualization();
  update3DVisualization();
  updateFlowVisualization();
}

function updateDEMVisualization() {
  if (!demCtx || samplePoints.length === 0) return;
  
  const width = demCanvas.width;
  const height = demCanvas.height;
  
  // Clear canvas
  demCtx.fillStyle = '#f8f9fa';
  demCtx.fillRect(0, 0, width, height);
  
  // Create elevation grid (simplified for demo)
  const elevs = samplePoints.map(p => p.elev);
  const minElev = Math.min(...elevs);
  const maxElev = Math.max(...elevs);
  const elevRange = maxElev - minElev || 1;
  
  // Draw elevation-based colors
  const gridSize = 20;
  for (let x = 0; x < width; x += gridSize) {
    for (let y = 0; y < height; y += gridSize) {
      // Simplified elevation mapping
      const elevIndex = Math.floor((x / width + y / height) * samplePoints.length / 2) % samplePoints.length;
      const elev = samplePoints[elevIndex].elev;
      const intensity = (elev - minElev) / elevRange;
      
      // Color based on elevation
      const r = Math.floor(100 + intensity * 155);
      const g = Math.floor(150 + intensity * 105);
      const b = Math.floor(200 - intensity * 100);
      
      demCtx.fillStyle = `rgb(${r},${g},${b})`;
      demCtx.fillRect(x, y, gridSize, gridSize);
      
      // Add hillshade effect
      if (showHillshade) {
        demCtx.fillStyle = `rgba(0,0,0,${0.3 * (1 - intensity)})`;
        demCtx.fillRect(x, y, gridSize, gridSize);
      }
    }
  }
  
  // Add contour lines
  demCtx.strokeStyle = 'rgba(255,255,255,0.3)';
  demCtx.lineWidth = 1;
  for (let i = 0; i < 5; i++) {
    const contourLevel = minElev + (i * elevRange / 4);
    demCtx.beginPath();
    // Simplified contour drawing
    demCtx.moveTo(0, height * (i / 5));
    demCtx.lineTo(width, height * (i / 5));
    demCtx.stroke();
  }
  
  // Add title
  demCtx.fillStyle = '#000';
  demCtx.font = '14px Arial';
  demCtx.fillText(`Digital Elevation Model (Range: ${minElev.toFixed(0)} - ${maxElev.toFixed(0)} m)`, 10, 20);
}

function update3DVisualization() {
  if (!threeDCtx || samplePoints.length === 0) return;
  
  const width = threeDCanvas.width;
  const height = threeDCanvas.height;
  
  // Clear canvas
  threeDCtx.fillStyle = '#87CEEB';
  threeDCtx.fillRect(0, 0, width, height);
  
  const elevs = samplePoints.map(p => p.elev);
  const minElev = Math.min(...elevs);
  const maxElev = Math.max(...elevs);
  const elevRange = maxElev - minElev || 1;
  
  // Draw 3D terrain
  const points = samplePoints.map((p, i) => {
    const angle = (i / samplePoints.length) * Math.PI * 2 + (threeDRotation * Math.PI / 180);
    const x = width / 2 + Math.cos(angle) * (width / 3);
    const y = height / 2 - (p.elev - minElev) / elevRange * (height / 3) + Math.sin(angle) * (width / 6);
    return { x, y, elev: p.elev };
  });
  
  // Draw terrain surface
  threeDCtx.fillStyle = '#8FBC8F';
  threeDCtx.beginPath();
  threeDCtx.moveTo(points[0].x, points[0].y);
  for (let i = 1; i < points.length; i++) {
    threeDCtx.lineTo(points[i].x, points[i].y);
  }
  threeDCtx.lineTo(width, height);
  threeDCtx.lineTo(0, height);
  threeDCtx.closePath();
  threeDCtx.fill();
  
  // Draw elevation points
  points.forEach(point => {
    threeDCtx.fillStyle = '#333';
    threeDCtx.beginPath();
    threeDCtx.arc(point.x, point.y, 3, 0, Math.PI * 2);
    threeDCtx.fill();
  });
  
  // Add title and info
  threeDCtx.fillStyle = '#000';
  threeDCtx.font = '14px Arial';
  threeDCtx.fillText('3D Terrain View', 10, 20);
  threeDCtx.font = '12px Arial';
  threeDCtx.fillText(`Rotation: ${threeDRotation}° | Elevation range: ${minElev.toFixed(0)}-${maxElev.toFixed(0)}m`, 10, 40);
}

function updateFlowVisualization() {
  if (!flowCtx || samplePoints.length === 0) return;
  
  const width = flowCanvas.width;
  const height = flowCanvas.height;
  
  // Clear canvas
  flowCtx.fillStyle = '#f8f9fa';
  flowCtx.fillRect(0, 0, width, height);
  
  // Draw base terrain
  const elevs = samplePoints.map(p => p.elev);
  const minElev = Math.min(...elevs);
  const maxElev = Math.max(...elevs);
  const elevRange = maxElev - minElev || 1;
  
  // Draw elevation background
  for (let i = 0; i < samplePoints.length - 1; i++) {
    const x1 = (i / (samplePoints.length - 1)) * width;
    const x2 = ((i + 1) / (samplePoints.length - 1)) * width;
    const elev1 = samplePoints[i].elev;
    const elev2 = samplePoints[i + 1].elev;
    
    const intensity1 = (elev1 - minElev) / elevRange;
    const intensity2 = (elev2 - minElev) / elevRange;
    
    const gradient = flowCtx.createLinearGradient(x1, 0, x2, 0);
    gradient.addColorStop(0, `hsl(120, 70%, ${30 + intensity1 * 40}%)`);
    gradient.addColorStop(1, `hsl(120, 70%, ${30 + intensity2 * 40}%)`);
    
    flowCtx.fillStyle = gradient;
    flowCtx.fillRect(x1, 0, x2 - x1, height);
  }
  
  // Draw downhill arrows
  if (showArrows) {
    for (let i = 0; i < samplePoints.length - 1; i++) {
      const x = ((i + 0.5) / (samplePoints.length - 1)) * width;
      const y = height / 2;
      
      const elev1 = samplePoints[i].elev;
      const elev2 = samplePoints[i + 1].elev;
      const slope = Math.abs(elev2 - elev1);
      
      // Arrow direction (downhill)
      const direction = elev2 < elev1 ? 1 : -1;
      const arrowSize = 10 + slope * 5;
      
      flowCtx.save();
      flowCtx.translate(x, y);
      flowCtx.rotate(direction * Math.PI / 2);
      
      flowCtx.fillStyle = '#d9534f';
      flowCtx.beginPath();
      flowCtx.moveTo(0, -arrowSize);
      flowCtx.lineTo(-arrowSize/2, 0);
      flowCtx.lineTo(arrowSize/2, 0);
      flowCtx.closePath();
      flowCtx.fill();
      
      flowCtx.restore();
    }
  }
  
  // Add title
  flowCtx.fillStyle = '#000';
  flowCtx.font = '14px Arial';
  flowCtx.fillText('Downhill Flow Direction', 10, 20);
  flowCtx.font = '12px Arial';
  flowCtx.fillText('Red arrows point downhill | Size indicates slope steepness', 10, 40);
}

function exportDEM() {
  const link = document.createElement('a');
  link.download = 'dem_visualization.png';
  link.href = demCanvas.toDataURL();
  link.click();
}

function export3D() {
  const link = document.createElement('a');
  link.download = '3d_terrain.png';
  link.href = threeDCanvas.toDataURL();
  link.click();
}

function exportFlow() {
  const link = document.createElement('a');
  link.download = 'flow_direction.png';
  link.href = flowCanvas.toDataURL();
  link.click();
}

// ---------- Sampling & Elevation ----------
async function analyze(){
  if(!currentGeometry || currentGeometry.coords.length<2) return alert('Draw or load coordinates first');
  
  const step = Math.max(1, parseFloat(document.getElementById('sampleDist').value) || 50);
  const source = document.getElementById('elevSource').value;
  
  showStatus(`Starting analysis with ${source}...`, 'info');
  
  // sample along polyline (for polygon use its exterior perimeter as polyline)
  let poly = currentGeometry.coords.slice();
  if(currentGeometry.type === 'polygon'){
    // ensure closed
    if(poly[0][0] !== poly[poly.length-1][0] || poly[0][1] !== poly[poly.length-1][1]) poly.push(poly[0]);
  }
  
  const samples = resamplePolyline(poly, step); // [{lat,lng}]
  showStatus(`Sampled ${samples.length} points. Fetching elevations...`, 'info');
  
  // fetch elevations with automatic fallback if no elevation variation detected
  let elevs = await fetchElevationsWithFallback(samples, source);
  
  if(!elevs){ 
    showStatus('All elevation services failed. Please try again later or use different coordinates.', 'error');
    return; 
  }
  
  showStatus('Elevation data loaded successfully! Calculating slopes...', 'success');
  
  // merge
  samplePoints = samples.map((s,i)=>({lat:s[0], lng:s[1], elev: elevs[i], source}));
  
  // compute slopes & distances
  const pairs = [];
  for(let i=0;i<samplePoints.length-1;i++){
    const a=samplePoints[i], b=samplePoints[i+1];
    const d = haversineMeters(a.lat,a.lng,b.lat,b.lng);
    const dz = b.elev - a.elev;
    const slope = d>0 ? Math.abs(dz)/d : 0; // absolute (no minuses)
    pairs.push({i, i1:i+1, dist:d, dz:dz, slope: slope, from:[a.lat,a.lng], to:[b.lat,b.lng]});
  }
  
  // compute pairwise slopes (all possible pairs)
  const pairwise = [];
  for(let i=0;i<samplePoints.length;i++){
    for(let j=i+1;j<samplePoints.length;j++){
      const a=samplePoints[i], b=samplePoints[j];
      const d = haversineMeters(a.lat,a.lng,b.lat,b.lng);
      const dz = b.elev - a.elev;
      const slope = d>0 ? Math.abs(dz)/d : 0;
      pairwise.push({i,j,dist:d,dz, slope});
    }
  }
  
  // general slope of area: (max elev - min elev) / max horizontal distance among samples
  const elevsOnly = samplePoints.map(p=>p.elev);
  const maxElev = Math.max(...elevsOnly);
  const minElev = Math.min(...elevsOnly);
  let maxDist = 0;
  for(let i=0;i<samplePoints.length;i++){
    for(let j=i+1;j<samplePoints.length;j++){
      const d = haversineMeters(samplePoints[i].lat,samplePoints[i].lng, samplePoints[j].lat,samplePoints[j].lng);
      if(d>maxDist) maxDist = d;
    }
  }
  const generalSlope = maxDist>0 ? Math.abs(maxElev-minElev)/maxDist : 0;
  
  // area (if polygon)
  let area = 0;
  if(currentGeometry.type==='polygon'){
    // use vertices without the closing repeated point
    let polyCoords = currentGeometry.coords.slice();
    if(polyCoords[0][0] === polyCoords[polyCoords.length-1][0] && polyCoords[0][1] === polyCoords[polyCoords.length-1][1]) polyCoords = polyCoords.slice(0,-1);
    area = polygonAreaMeters(polyCoords);
  }

  // render results
  renderResults({pairs, pairwise, generalSlope, maxElev, minElev, maxDist, area});
  renderChart(samplePoints);
  renderMapSamples();
  
  // NEW: Show and update visualizations
  showVisualizations();
  initializeVisualizations();
  updateVisualizations();
  
  showStatus('Analysis complete!', 'success');
  setTimeout(() => showStatus('', 'info'), 3000);
}

// NEW: Smart elevation fetching with automatic fallback
async function fetchElevationsWithFallback(samples, primarySource) {
  let elevs = await fetchElevations(samples, primarySource);
  
  // Check if we got valid elevation data with variation
  if (elevs && hasElevationVariation(elevs)) {
    return elevs;
  }
  
  // If primary source failed or has no variation, try fallbacks
  const fallbackOrder = getFallbackOrder(primarySource);
  
  for (const fallbackSource of fallbackOrder) {
    showStatus(`${primarySource} failed or no elevation variation. Trying ${fallbackSource}...`, 'error');
    elevs = await fetchElevations(samples, fallbackSource);
    
    if (elevs && hasElevationVariation(elevs)) {
      showStatus(`Successfully used ${fallbackSource} as fallback`, 'success');
      return elevs;
    }
  }
  
  // If all sources fail but we have some data, return it with warning
  if (elevs) {
    showStatus('Warning: All elevation sources show minimal variation. Data may be inaccurate.', 'error');
    return elevs;
  }
  
  return null;
}

// NEW: Check if elevation data has meaningful variation
function hasElevationVariation(elevs) {
  if (!elevs || elevs.length === 0) return false;
  
  const uniqueElevations = [...new Set(elevs.map(e => Math.round(e * 10)))];
  const elevationRange = Math.max(...elevs) - Math.min(...elevs);
  
  // Consider it valid if we have at least 2 different elevation values 
  // OR significant elevation range (> 1 meter)
  return uniqueElevations.length > 1 || elevationRange > 1;
}

// NEW: Define fallback order based on primary source
function getFallbackOrder(primarySource) {
  const allSources = [
    'opentopodata',
    'opentopodata-aster', 
    'airbus-elevation',
    'open-elevation',
    'nationalmap-usgs'
  ];
  
  // Remove primary source from the list
  const fallbacks = allSources.filter(source => source !== primarySource);
  
  // Reorder based on reliability
  const priorityOrder = [
    'opentopodata',
    'opentopodata-aster',
    'airbus-elevation', 
    'open-elevation',
    'nationalmap-usgs'
  ];
  
  // Sort fallbacks by priority order
  return fallbacks.sort((a, b) => {
    return priorityOrder.indexOf(a) - priorityOrder.indexOf(b);
  });
}

// resample polyline with approx spacing (meters)
function resamplePolyline(latlngs, stepM){
  const out = [];
  for(let i=0;i<latlngs.length-1;i++){
    const a = latlngs[i], b = latlngs[i+1];
    const seg = haversineMeters(a[0],a[1],b[0],b[1]);
    const n = Math.max(1, Math.ceil(seg/stepM));
    for(let j=0;j<n;j++){
      const t = j/n;
      const lat = a[0] + (b[0]-a[0])*t;
      const lng = a[1] + (b[1]-a[1])*t;
      out.push([lat,lng]);
    }
  }
  out.push(latlngs[latlngs.length-1]); // last
  return out;
}

// UPDATED: elevation fetch with new services
async function fetchElevations(samples, source){
  try{
    const results = [];
    const batchSize = 50;
    let dataset = 'srtm90m';
    
    if(source === 'opentopodata-aster') {
      dataset = 'aster30m';
    }
    
    for(let i=0;i<samples.length;i+=batchSize){
      const chunk = samples.slice(i,i+batchSize);
      const locations = chunk.map(p=>`${p[0]},${p[1]}`).join('|');
      
      let url;
      if(source.startsWith('opentopodata')){
        url = `https://api.opentopodata.org/v1/${dataset}?locations=${encodeURIComponent(locations)}`;
      } else if (source === 'airbus-elevation') {
        // Airbus Elevation API - free, no key needed
        const points = chunk.map(p => ({ lat: p[0], lon: p[1] }));
        const response = await fetch('https://elevation.airbus.com/api/elevation', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ points: points })
        });
        
        if (!response.ok) throw new Error(`Airbus API error: ${response.status}`);
        const data = await response.json();
        
        if (data.elevations && Array.isArray(data.elevations)) {
          results.push(...data.elevations);
        } else {
          throw new Error('Airbus API: Invalid response format');
        }
        
        // Continue to next batch
        await new Promise(res=>setTimeout(res, 500));
        continue;
      } else if (source === 'nationalmap-usgs') {
        // USGS National Map Elevation API (US only)
        const locationsUSGS = chunk.map(p => `${p[1]},${p[0]}`).join(',');
        url = `https://epqs.nationalmap.gov/v1/json?x=${locationsUSGS}&units=Meters&output=json`;
      } else {
        // Open-Elevation
        url = `https://api.open-elevation.com/api/v1/lookup?locations=${encodeURIComponent(locations)}`;
      }
      
      showStatus(`Fetching elevations ${i+1}-${Math.min(i+batchSize, samples.length)}/${samples.length} from ${source}...`, 'info');
      
      // Skip fetch for Airbus since we already handled it
      if (source !== 'airbus-elevation') {
        const resp = await fetch(url);
        if(!resp.ok) {
          const errorText = await resp.text();
          console.error(`${source} error:`, resp.status, errorText);
          
          // Check for rate limiting
          if(resp.status === 429) {
            showStatus('Rate limit exceeded. Waiting before retry...', 'error');
            await new Promise(res=>setTimeout(res, 2000));
            // Try one more time
            const retryResp = await fetch(url);
            if(!retryResp.ok) {
              throw new Error(`Rate limit persists: ${retryResp.status}`);
            }
            const retryJs = await retryResp.json();
            processElevationResponse(retryJs, results, source);
          } else {
            throw new Error(`${source} error ${resp.status}: ${errorText}`);
          }
        } else {
          const js = await resp.json();
          processElevationResponse(js, results, source);
        }
      }
      
      // Increased delay to reduce rate issues
      await new Promise(res=>setTimeout(res, 800));
    }
    
    // Final validation
    if (results.length !== samples.length) {
      throw new Error(`Expected ${samples.length} elevations but got ${results.length}`);
    }
    
    return results;
  }catch(err){
    console.error('Elevation fetch failed:', err);
    showStatus(`Elevation fetch from ${source} failed: ${err.message}`, 'error');
    return null;
  }
}

// NEW: Helper function to process elevation responses from different APIs
function processElevationResponse(js, results, source) {
  if (source === 'nationalmap-usgs') {
    // USGS response format
    if (js && js.USGS_Elevation_Point_Query_Service && js.USGS_Elevation_Point_Query_Service.Elevation_Query) {
      js.USGS_Elevation_Point_Query_Service.Elevation_Query.forEach(r => {
        results.push(r.Elevation !== null && r.Elevation !== undefined ? r.Elevation : 0);
      });
    } else {
      throw new Error('USGS: Invalid response format');
    }
  } else if (source.startsWith('opentopodata')) {
    // OpenTopoData response format
    if (!js.results) throw new Error(`${source}: no results`);
    js.results.forEach(r => {
      results.push(r.elevation !== null && r.elevation !== undefined ? r.elevation : 0);
    });
  } else if (source === 'open-elevation') {
    // Open-Elevation response format
    if (!js.results) throw new Error(`${source}: no results`);
    js.results.forEach(r => {
      results.push(r.elevation !== null && r.elevation !== undefined ? r.elevation : 0);
    });
  }
}

// render map sample markers and line
let sampleLayer = L.layerGroup().addTo(map);
function renderMapSamples(){
  sampleLayer.clearLayers();
  if(samplePoints.length===0) return;
  const latlngs = samplePoints.map(p=>[p.lat,p.lng]);
  L.polyline(latlngs, {color:'#d9534f', weight:3}).addTo(sampleLayer);
  samplePoints.forEach((p,i)=>{
    const m = L.circleMarker([p.lat,p.lng], {radius:4, color:'#0b7285'}).addTo(sampleLayer);
    m.bindPopup(`pt ${i+1}<br/>elev: ${p.elev} m<br/>source: ${p.source}`);
  });
  map.fitBounds(latlngs);
}

// render chart
let xsChart = null;
function renderChart(points){
  const dists = [0];
  for(let i=1;i<points.length;i++){
    const d = haversineMeters(points[i-1].lat,points[i-1].lng,points[i].lat,points[i].lng);
    dists.push(dists[i-1] + d);
  }
  const labels = dists.map(d=>d.toFixed(1));
  const elevs = points.map(p=>p.elev);
  const ctx = document.getElementById('xsChart').getContext('2d');
  if(xsChart) xsChart.destroy();
  xsChart = new Chart(ctx, {
    type:'line',
    data:{
      labels: labels,
      datasets:[{label:'Elevation (m)', data:elevs, fill:true, tension:0.2}]
    },
    options:{
      plugins:{legend:{display:false}},
      scales:{ x: { title:{display:true,text:'Distance (m)'} }, y: { title:{display:true,text:'Elevation (m)'} } }
    }
  });
  window.xsChart = xsChart;
}

// render results table/summary
function renderResults(obj){
  const {pairs, pairwise, generalSlope, maxElev, minElev, maxDist, area} = obj;
  const avgAdjacentSlope = pairs.length ? (pairs.reduce((a,b)=>a + Math.abs(b.slope),0)/pairs.length) : 0;
  const maxPairwise = pairwise.length ? pairwise.reduce((a,b)=> b.slope>a.slope?b:a ) : null;
  const summaryEl = document.getElementById('summary');
  summaryEl.innerHTML = `
    <div><b>Sample points:</b> ${samplePoints.length}</div>
    <div><b>Area:</b> ${area? (area.toFixed(1)+' m² ('+(area/10000).toFixed(3)+' ha)') : 'N/A (not polygon)'}</div>
    <div><b>Elevation range:</b> ${minElev} m — ${maxElev} m (Δ ${ (maxElev-minElev).toFixed(2)} m)</div>
    <div><b>General slope (max Δe / max horizontal distance):</b> ${generalSlope.toFixed(5)} m/m (${(generalSlope*100).toFixed(2)} %)</div>
    <div><b>Average adjacent slope:</b> ${avgAdjacentSlope.toFixed(5)} m/m (${(avgAdjacentSlope*100).toFixed(2)} %)</div>
    <div><b>Max pairwise slope:</b> ${maxPairwise ? maxPairwise.slope.toFixed(5)+' m/m ('+(maxPairwise.slope*100).toFixed(2)+' %) between pts '+maxPairwise.i+' & '+maxPairwise.j : 'N/A'}</div>
    <div class="small" style="margin-top:6px">All slope values are <b>absolute</b> (no negative values). Distances use haversine (approx.). Elevation source shown per point.</div>
  `;

  // table of adjacent segments
  const tbl = document.createElement('table');
  tbl.innerHTML = `<thead><tr><th>#</th><th>From (lat,lng)</th><th>To (lat,lng)</th><th>Dist (m)</th><th>Δz (m)</th><th>Slope (m/m)</th></tr></thead>`;
  const tbody = document.createElement('tbody');
  pairs.forEach((p,idx)=>{
    const r = document.createElement('tr');
    r.innerHTML = `<td>${idx+1}</td>
      <td>${p.from[0].toFixed(6)}, ${p.from[1].toFixed(6)}</td>
      <td>${p.to[0].toFixed(6)}, ${p.to[1].toFixed(6)}</td>
      <td>${p.dist.toFixed(1)}</td>
      <td>${p.dz.toFixed(2)}</td>
      <td>${p.slope.toFixed(5)}</td>`;
    tbody.appendChild(r);
  });
  tbl.appendChild(tbody);
  const box = document.getElementById('tableBox');
  box.innerHTML = '';
  box.appendChild(tbl);
}

// export CSV
document.getElementById('btnExportCSV').addEventListener('click', ()=>{
  if(!samplePoints.length) return alert('No samples to export');
  let csv = 'index,lat,lng,elevation_m,source\n';
  samplePoints.forEach((p,i)=> csv += `${i+1},${p.lat},${p.lng},${p.elev},${p.source}\n`);
  // also append adjacent pairs
  csv += '\nseg_index,from_idx,to_idx,dist_m,dz_m,slope_m_per_m\n';
  const pairs = [];
  for(let i=0;i<samplePoints.length-1;i++){
    const a=samplePoints[i], b=samplePoints[i+1];
    const d = haversineMeters(a.lat,a.lng,b.lat,b.lng);
    const dz = b.elev - a.elev;
    const slope = d>0? Math.abs(dz)/d : 0;
    csv += `${i+1},${i+1},${i+2},${d.toFixed(2)},${dz.toFixed(3)},${slope.toFixed(6)}\n`;
  }
  const blob = new Blob([csv], {type:'text/csv'});
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a'); a.href=url; a.download='slope_results.csv'; document.body.appendChild(a); a.click(); a.remove(); setTimeout(()=>URL.revokeObjectURL(url),2000);
});

// ---------- UI wiring ----------
document.getElementById('btnAnalyze').addEventListener('click', analyze);

// For convenience: double click map to add point and update geometry
map.on('dblclick', e=>{
  if(!isDrawing) {
    addPoint([e.latlng.lat, e.latlng.lng]);
  }
});

// Initialize visualizations on load
document.addEventListener('DOMContentLoaded', function() {
  initializeVisualizations();
  hideVisualizations();
});

// show click on sample to view more -> handled by popups when rendering
// initial message
updateCoordsBox();

</script>
</body>
  </html>
